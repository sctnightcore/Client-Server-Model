TCP: (transmission control protocol) sockets are connection-oriented and constantly
    verify the delivey of the packets sent beteen them.




       1. client/server are two file descriptors
          These two variables store the values returned 
          by the socket system call and the accept system call.

       2. portNum is for storing port number on which
         the accepts connections

       3. isExit is bool variable which will be used to 
         end the loop

       4. The server reads characters from the socket 
         connection into a dynamic variable (buffer).

       5. A sockaddr_in is a structure containing an internet 
         address. This structure is already defined in netinet/in.h, so
         we don't need to declare it again.

        DEFINITION:
        struct sockaddr_in
        {
          short   sin_family;
          u_short sin_port;
          struct  in_addr sin_addr;
          char    sin_zero[];
        };
        
        sin_family:specifies the address family, ususally the constant "AF_INET".
      
        sin_port: specifies the port number and must be used with htons()
                  which is a function that converts the "host byte order" to 
                  "network byte order" so it can transmitted and routed properly when
                  opennig the socket connection. the reason for this is that computers and network 
                  protocols order their bytes in a non-compatible fashion, each the opposite of the other.

        sin_addr: holds the IP address return by inet_addr() to be used in the socket connection
        sin_zero: used with a char array buffer, usually set to 0

        Inet_addr(): this function takes the string you pass into it as an argument and converts it 
                     to the required form for use in the socket connection, negating th need to use htonl()
        


        6. serv_addr will contain the address of the server

        7. socklen_t  is an int type of width of at least 32 bits

        The socket() function creates a new socket.
        It takes 3 arguments,
            a. AF_INET: address domain of the socket.

            b. SOCK_STREAM: Type of socket. a stream socket in 
            which characters are read in a continuous stream (TCP)

            c. Third is a protocol argument: should always be 0. The 
            OS will choose the most appropiate protocol.
            This will return a small integer and is used for all 
            references to this socket. If the socket call fails, 
            it returns -1.
    
 /* 
        The variable server_addr is a structure of sockaddr_in. 

        sin_family contains a code for the address family. 
        It should always be set to AF_INET.

        INADDR_ANY contains the IP address of the host. For 
        server code, this will always be the IP address of 
        the machine on which the server is running.

        htons() converts the port number from host byte order 
        to a port number in network byte order.
    */

      /* 
        The bind() system call binds a socket to an address, 
        in this case the address of the current host and port number 
        on which the server will run(sockaddr_in). It takes three arguments, 
       1, the socket file descriptor. 
       2, The second argument is a pointer 
        to a structure of type sockaddr, this must be cast to
        the correct type.
    */


  /* 
        The listen system call allows the process to listen 
        on the socket for connections. 
        The program will be stay idle here if there are no 
        incomming connections.
        The first argument is the socket file descriptor, 
        and the second is the size for the number of clients 
        i.e the number of connections that the server can 
        handle while the process is handling a particular 
        connection. The maximum size permitted by most 
        systems is 5.
    */


    /* 
        The accept() system call causes the process to block 
        until a client connects to the server. Thus, it wakes 
        up the process when a connection from a client has been 
        successfully established. It returns a new file descriptor, 
        and all communication on this connection should be done 
        using the new file descriptor. The second argument is a 
        reference pointer to the address of the client on the other 
        end of the connection, and the third argument is the size 
        of this structure.
    */

     /* 
            Note that we would only get to this point after a 
            client has successfully connected to our server. 
            This reads from the socket. Note that the read() 
            will block until there is something for it to read 
            in the socket, i.e. after the client has executed a 
            the send().
            It will read either the total number of characters 
            in the socket or 1024
        */
  /* 
            Once a connection has been established, both ends 
            can both read and write to the connection. Naturally, 
            everything written by the client will be read by the 
            server, and everything written by the server will be 
            read by the client.
        */

    

      /* 
            Once the server presses # to end the connection,
            the loop will break and it will close the server 
            socket connection and the client connection.
        */


/*


The server and client port numbers MUST match. The port number is part of the address 
of the server. If the client applies wrong address, i.e. wrong port number OR wrong server
 address, the message would be delivered to wrong recipient. Much like postal addresses.
  If you are writing to your friend, you have to mention street number AND city. If you 
  put wrong street number, the letter would reach somewhere else.

AND then you MUST use a port number that is not in use. 80 is a well known port number; 
reserved for HTTP. If a port number is used, you cannot allocate it to someone else. On 
your machine port 80 may be in use. You would not want your home street address to be
 allocated to someone else OR someone else allocated the same house as yours. That would
  be inconvenient. You can imagine what would happen if computers allowed two programs to
   use same port number.

You can always evict someone from their well known port number. You can shut off the web 
server, if one is running on your machine, and then write client/server app to use port 80.

You can use 192.xxx addresses. Provided that the firewalls on your computers are not
 blocking it. Because while loopback loops back within the computer, the 192.xx addressing 
 scheme would cause the packets to go out on LAN and come back. I may be wrong on this one,
  on some operating systems. Experiment and let us know if this is right or wrong.
